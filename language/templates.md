# Embedded Puppet - EPP

The template based text generation feature Embedded Puppet (EPP) is an integral part of the Puppet Programming Language that allows template text to contain free form text intermixed with logic expressed in the Puppet Programming Language for the purpose of producing repeating or conditional text content.

EPP is to the Puppet Programming Language what ERB is to Ruby, and EPP supports the same template tags as ERB. While the two technologies are similar, they are not identical.

EPP is used via two functions supplied with puppet (`epp` and `inline_epp`). This specification does not limit the set of functions that may provide different ways of invoking or using the EPP template features.

### EPP Functions

EPP template text is processed by the two epp functions:

* `epp(template_name, optional_args_hash)` - for evaluating an `.epp` file
* `inline_epp(epp_text_string, optional_args_hash)` - for evaluating a string in EPP syntax

When EPP-text is evaluated the result is a String.

#### Visibility of Scoped Variables

In order to encourage template reuse and foster good best practices regarding separation of
concerns, the scoping rules of the EPP functions are as follows:

* Both `inline_epp()` and `epp()` always provide access to the global (i.e. top/node) scope 
  variables.
* `inline_epp()` provides access to the local calling scope's variables unless an
  (optional) hash of variable name/value entries is given in which case these are used **instead** 
  of having access to the local scope variables.
* The `epp` function does not provide access to the calling scope's variables.  
* If a template declares parameters that require a value to be given, these must be given in 
  the name/value hash.
  
In other words, an external (non-inline) template behaves as a function, and an inline
template behaves as a lambda or as a function depending on if it has defined parameters, or is given variables in a hash.

#### inline_epp function

The `inline_epp` function is given a String containing the EPP source text. The function optionally takes a Hash of variable name to value mappings. 

#### epp function

The `epp` function processes EPP source text in a file (the template file).
The first argument to this function should be the file to to take the EPP source text
from, given either as a absolute path, or as a module specific symbolic path on the form `<MODULE_NAME>/<TEMPLATE_FILE>`.
Such a symbolic reference will load `<TEMPLATE_FILE>` from the given module's `templates`
directory. (For example, the reference `apache/vhost.conf.epp` will load the
file `<MODULE_PATH>/apache/templates/vhost.conf.epp`.)

A module based reference enforces that the file must end with `'.epp'` while it allows that the reference is made without the `'.epp'` suffix which it then adds automatically. (For example, the reference `apache/vhost.conf`, is the same template reference as `apache/vhost.conf.epp`).

For an absolute path, the path is used as given if the file exists. If the absolute path is referencing a non-existing file, the `'.epp'` suffix is appended in a second attempt to load the template.

It is an error if the referenced template file does not exist.

### EPP Template Text

An EPP lexical text processor (epp-lexer) starts in 'text mode', and delivers a token stream to the EPP parser. In addition to the token delivered for the Puppet Programming Language source text,
the epp-lexer also delivers the following tokens:

* `EPP_START` - a token that indicates the beginning of EPP text
* `RENDER_STRING` - a verbatim sequence of characters

Below is the EPP Specific part of the Puppet Language Grammar, where parts of the general Puppet Program grammar is shown to illustrate how EPP is wired into the language:

    program
      : statements      # A non EPP Puppet Program
      | epp_expression  # An EPP Puppet Program

    statements
       : ... # All statements in the Puppet Programming Language (structure not shown)
       | primary_expression
       
    primary_expression
      : ... # all expressions that are primary expression in the Puppet Language (not shown)
      | epp_render_expression
      
    epp_expression
      : EPP_START epp_parameters_list? statements?

    epp_parameters_list
      : '|' (parameters ','?)? '|'  # parameters is the same as for a lambda

    epp_render_expression
      : RENDER_STRING
      | '<%=' expression ('%> | '-%>')
      | '<%=' '{' statements '}' ('%> | '-%>')


The `EPP_START` token is automatically generated by the epp-lexer at the start of the EPP source text. It can be followed by an optional parameter list and optional statements if
the first line of the EPP source text contains an opening `<%` that is not preceded by any text,
or a `<%-` that is not preceded by any non whitespace text. In other words; it is not possible to introduce a template's parameters after any template text has been rendered.

Example start of an EPP template with parameters:

    <%- | $x, $y, $z = 'this is a default value' | -%>

All other occurrences of the EPP tokens `<%`,`<%-` or `<%=` will change the epp-lexer's mode from
text-mode to puppet-mode. 
When in puppet-mode, the epp-lexer delivers tokens to the grammar as for any puppet program. 
When the epp-lexer sees an EPP-end token (`%>` or `-%>`) it switches back to text-mode and delivers any verbatim text as a `RENDER_STRING` token. The template text must end in text-mode. In other words; all EPP tags must be closed. There are also EPP-tags that do not change mode to allow rendering of EPP tags, and to introduce comments in text.

When the resulting EPP program is evaluated, it is evaluated the same way as a non EPP Puppet Program is with the addition that at the end of the evaluation, the results of the RENDER_STRING expressions are concatenated into one string and returned as the result.

> NOTE:
> EPP tags do not nest! When in puppet-mode, it is not possible to again enter nested text-mode.
> It is however allowed to call one of the EPP functions to
> nest the result of evaluating another template.

> NOTE: whitespace text is significant
> Care must be taken to not introduce whitespace text in the middle of embedded puppet logic
> since that would lead to syntax errors.

Rules:

* An `epp_render_expression` produces a string result as a side effect that is concatenated at
  the end of the process.
* Each invocation of an `epp_render_expression` has `undef` value.
* For a `render_epp_expression` that contains a block expression (with multiple statements), the
  result of the block is rendered (the last expression).
* Variables that are assigned in the template are local to the template.
* A local variable introduced in the template may shadow a variable in an outer scope.
* Variables in a template are immutable.

This means that it is not possible to assign the result of verbatim text or to pass verbatim
text as an argument in a function call.

    <% $a = %> text <%= $a %>
    
This produces the result `" text "`. The first assignment to `$a` sets `$a` to `undef`, and the second will interpolate an empty string since `$a` is `undef`.

    <% notice ( "a", %> text <%, "b" ) %>

This will notice `"a  b"`, because the verbatim text produces `undef`.

### EPP Tags and their meaning

| tag | description |
| --- | --- |
| `<%`  | Switches to puppet mode. Whitespace to the left of the tag is rendered (no left trimming)|
| `<%=` | Switches to puppet expression mode. (Left trimming is not possible) |
| `<%%` |Â A literal `<%` is rendered, mode does not change |
| `%%>` | A literal `%>` is rendered, mode does not change |
| `<%-` | Switches to puppet mode. Whitespace preceding the tag, up to and including a new line is not rendered. |
| `<%#` | A comment not included in the output (up to the next `%>`, or right trimming `-%>`). Continues in text mode after having skipped the comment (observes right trimming semantics).
| `%>` | Ends puppet mode
| `-%>` | Ends puppet mode and trims any generated trailing whitespace |


### Examples

    $x = droid
    notice inline_epp(@(END))
    This is the <%= $x %> you are looking for!
    | END

Produces a notice of the string "This is the droid you are looking for!"
    
    $a = world
    notice inline_epp(@(END), {x => magic})
      <%-( $x )-%>
      <% Integer[1,3].each |$count| { %>
      hello epp <%= $x %> <%= $a %> <%= $count %>
      <%- } %>
      |- END

Produces the following output:

    Notice: Scope(Class[main]): 
    hello epp magic world 1
    hello epp magic world 2
    hello epp magic world 3

(In the example above `$a` resulted in `"world"` because all of the logic is in the global scope).

